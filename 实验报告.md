实验报告：体育成绩管理系统设计与实现

2．系统总体设计

2.1 问题分析
本系统旨在解决学校体育成绩管理的问题。体育成绩包含多项指标（如身高、体重、BMI、肺活量、立定跳远、1000m/800m跑等），且学生人数可能动态增删。因此，系统设计需要满足以下基本需求：
- 数据存储：能够存储和管理大量学生信息及其多项体育成绩。
- 动态维护：支持动态添加、删除和修改学生记录。
- 信息查询：提供高效的查询手段（如按姓名匹配）。
- 数据统计：支持对成绩进行排序和统计分析（如各项平均分）。
- 持久化：具备数据导入/导出功能（TXT、DAT、CSV），确保数据在程序退出后不丢失。

2.2 设计思路
1. 数据结构：采用单链表作为核心存储结构，通过结构体 `struct student` 封装学籍信息与体测数据。链表在处理数据增删时具有较高的灵活性。
2. 模块化构建：将底层逻辑（链表操作、文件I/O）与应用层逻辑（主界面、业务分发）解耦。`information.h` 负责底层实现，`mian.c` 负责用户交互。
3. 交互设计：采用菜单驱动的命令行界面，通过功能编号引导用户操作。
4. 鲁棒性：对文件读取、内存分配等关键环节增加错误检测。

2.3 程序结构
程序主要分为两个核心组件：
- information.h：数据层，包含结构体定义及所有核心操作函数。
- mian.c：展示层与控制层，包含 `main` 函数、菜单逻辑以及各功能包装函数 `gongX`。

2.4 功能模块
- 录入模块：支持手动单条录入或从TXT模板批量导入。
- 删除模块：支持根据学生姓名搜索并精准删除记录。
- 查询模块：快速检索并展示指定学生的详细体测报告。
- 显示模块：列表化展示系统中所有学生的各项成绩及总分。
- 修改模块：可对已录入学生的各项基本信息及其体测成绩进行修正。
- 排序模块：支持按总分、单项分或体重进行升序或降序排列。
- 统计模块：计算所有学生的单项及总分平均成绩，分析整体水平。
- 导出模块：将内存中的链表数据导出为 CSV 格式，方便与办公软件对接。

2.5 方法定义（所有方法）
- struct student* create_student_node(...)：初始化学生节点，根据性别自动匹配项目名称。
- void insert_student_list_tail(...)：将节点插入链表尾部。
- void insert_student_list_head(...)：将节点插入链表头部。
- void insert_student_list(...)：在链表指定位置插入节点。
- void delete_student_list_node(...)：根据位置删除特定节点。
- void delete_student_list(...)：系统关闭时清空链表，释放内存。
- struct student* search_student_list(...)：基于姓名的线性查找算法。
- void sort_student_list(...)：基于指针交换的冒泡排序。
- void modify_student_info(...)：动态修改指定字段。
- void save_student_list_to_file(...)：将链表持久化为二进制 DAT 文件。
- struct student* load_student_list_from_file(...)：启动时加载历史数据。
- void output_csv(...)：格式化输出为 CSV 流文件。
- int import_from_custom_txt(...)：解析 TXT 模版文件进行批量导入。

2.6 主程序流程
1. 初始化链表头指针，调用 load 函数检查历史存档。
2. 显示主菜单，提示用户当前系统是否有已存数据。
3. 接收用户指令：
   - 1-2：数据录入与删除。
   - 3-5：信息查询、全员展示与信息修改。
   - 8-12：高级分析功能（排序、导出、平均值计算）。
   - 0：退出系统。
4. 每次操作完成后，返回主菜单等待下一次输入。
5. 退出时，执行 delete_student_list 释放所有动态分配的堆空间。

2.7 模块调用关系
main()
└── xitong() / xitong_xiao() (界面交互)
└── gong1() -> import_from_custom_txt() / create_student_node() (录入链)
└── gong2() -> search_student_list() + delete_student_list_node() (删除链)
└── gong4() -> 遍历 next 指针 (显示链)
└── gong11() -> sort_student_list() (排序链)

--------------------------------------------------------------------------------

3．系统详细设计

3.1 核心数据结构设计
```c
struct student {
  char name[20];            // 姓名
  char school_number[20];   // 学号
  char class_name[20];      // 班级
  char grade[20];           // 年级
  float height;             // 身高
  float weight;             // 体重
  char sex[10];             // 性别
  char project_name[7][20]; // 体育项目名称（自动匹配性别）
  int project_score[7];     // 体育项目得分
  int total_score;          // 总分
  struct student *next;     // 指向后继节点的指针
};
```

3.2 模块算法实现

1. 创建与初始化算法 (create_student_node)
   - 输入：学生各项基本信息与成绩数组。
   - 算法逻辑：
     1. 利用 `malloc` 申请内存空间。
     2. 若成功，使用 `strcpy` 和直接赋值填充各数据域。
     3. 关键判定：根据 `sex` 字段判断（如 "男"），为 `project_name` 数组赋予 "1000m跑" 或 "800m跑" 等专属名称。
     4. 将 `next` 设为 `NULL` 以待链接。
   - 输出：新节点的首地址。

2. 链表排序算法 (sort_student_list)
   - 目的：对系统中的学生记录进行多维度（总分、单项分、体重）的升序或降序排列。
   - 算法核心：**基于二级指针的物理节点交换冒泡排序**。
   - 算法详细逻辑：
     1. **空值检查**：若链表为空或仅有一个节点，直接返回。
     2. **外层循环**：使用 `do-while` 结构，只要在本轮遍历中发生了交换（`swapped == 1`），则继续下一轮，直到序列完全有序。
     3. **二级指针初始化**：声明 `struct student **curr_ptr_ref` 指向 `head_ref`。**优势**：通过操作“指向节点的指针的地址”，可以统一处理“头节点交换”与“中间节点交换”的逻辑，无需编写冗长的 `if-else` 分支。
     4. **内层遍历与比较**：
        - 令 `p1 = *curr_ptr_ref`（当前节点），`p2 = p1->next`（后继节点）。
        - 根据传入的 `sort_type` 和 `sort_index` 决定比较变量（如 `p1->total_score` 与 `p2->total_score`）。
     5. **物理交换步骤（指针重定向）**：
        - 首先将 `p1->next` 指向 `p2->next`（剥离 p2）。
        - 将 `p2->next` 指向 `p1`（将 p1 挂在 p2 之后）。
        - 执行 `*curr_ptr_ref = p2`（修正前序节点的 next 指针，使其指向新的领先者 p2）。
        - 标记 `swapped = 1`。
     6. **指针推进**：每一项比较后，将 `curr_ptr_ref` 移动到下一个节点的 `next` 指针地址上。
   - 输出：原地重排后的链表。


3. 批量导入算法 (import_from_custom_txt)
   - 目的：解析特定格式的 TXT 模版文件，实现学生信息的批量自动化录入。
   - 算法详细逻辑：
     1. **初始化**：以只读模式 (`"r"`) 打开指定文件。初始化临时缓冲区 `line[256]` 和学生计数器 `count`。
     2. **逐行扫描**：通过 `while(fgets(...))` 循环遍历文件每一行，支持非结构化文本的模糊解析。
     3. **记录边界识别**：
        - 查找关键字 "学号"。若匹配，则视为新学生记录的起始。
        - **结算逻辑**：若当前已有正在处理的激活记录 (`has_active`)，则先调用 `create_student_node` 封装该学生数据，通过 `insert_student_list_tail` 挂载至链表尾部，并重置所有临时变量（姓名、成绩等）。
     4. **字段解析（键值对检索）**：
        - 查找冒泡标识（"：" 或 ":"）。
        - 利用 `strstr` 判断当前行属性（如 "姓名"、"性别"、"总分"、"身高"、"体重" 等）。
        - 使用 `sscanf` 从分隔符后的偏移位置提取数据并存入临时变量。
     5. **成绩提取算法**：
        - 针对包含 "分" 字样的成绩行，首先定位 "分" 的字符位置。
        - 采用**逆向搜索策略**：从 "分" 向前移动指针，跳过非数字字符，提取连续的一段数字字符。
        - 利用 `atoi` 将提取出的字符串转换为整数，并根据项目关键字（如 "BMI"、"肺活量"、"1000m" 等）映射到 `scores` 数组的相应下标。
     6. **收尾工作**：文件结束后，处理最后一个残留记录，关闭文件指针，返回 `count`。
   - 特点：具备较强的容错性，能处理包含描述性文字和不规则换行的 TXT 模版。


4. 查找与检索算法 (search_student_list)
   - 算法逻辑：
     1. 传入搜索关键字 `name`。
     2. 设临时指针指向头节点。
     3. 遍历链表，执行 `strcmp(ptr->name, name)`。
     4. 若结果为 0，立即返回当前节点地址；否则指针后移。
     5. 循环结束未找到则返回 `NULL`。

5. 个人信息动态修改算法 (modify_student_info)
   - 目的：允许用户根据索引实时更新特定学生的任何字段。
   - 算法逻辑：
     1. **定位学生**：遍历链表，利用 `strcmp` 寻找目标姓名。
     2. **分支处理**：根据 `info_index` 进入不同的逻辑分支。
     3. **字符串与数值转换**：
        - 对于 `char[]` 字段（名字、学号等），直接使用 `strcpy`。
        - 对于数值字段（身高、体重、成绩），使用 `atof` 或 `atoi` 将新信息字符串转换为相应类型。
     4. **联动修改**：**关键逻辑**——若修改了“性别”字段，算法会自动重新初始化 `project_name` 数组，将项目名称切换为对应性别的标准（如将 "1000m跑" 切换为 "800m跑"）。
     5. **跳出**：修改完成后立即结束函数，提高效率。

6. 统计与导出算法 (output_csv & 均值计算)
   - **CSV 导出逻辑**：
     1. 创建并打开以 `.csv` 结尾的文件。
     2. **写入表头**：手动写入符合 CSV 标准的逗号分隔标题行（姓名, 学号, ..., 总成绩）。
     3. **遍历写入**：通过 `while` 循环遍历链表，利用 `fprintf` 将每个节点的成员变量按顺序输出，每行代表一个学生。
     4. **数据格式化**：对身高体重保留一位小数，对整数成绩直接输出，确保兼容 Excel 等软件。
   - **均值统计逻辑**（gong12）：
     1. 维护一个长度为 `PROJECT_COUNT + 1` 的整型累加数组。
     2. 遍历链表，将每个学生的各项分数累加至数组，并计数学生总数。
     3. 遍历结束后，循环输出各项总数与总人数的商，得出科学的平均成绩分布。
