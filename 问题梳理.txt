体育成绩管理系统：开发过程中的问题梳理与解决方案

在系统的设计与开发过程中，我们遇到了若干关键的技术挑战和逻辑问题。以下是对这些问题的梳理及其最终的解决方案：

1. 数据解析异常（身高体重读取为0）
   - 问题描述：从外部 TXT 文件导入数据时，发现部分学生的“身高”和“体重”字段读取结果始终为 0，而“总分”或“项目分数”出现了异常的大数。
   - 原因分析：文件读取时使用的格式化字符串与实际文件中的分隔符（如中文冒泡、横杠等）不完全匹配，导致 `fscanf` 或 `sscanf` 发生偏移，解析失败。
   - 解决方案：引入了鲁棒性更强的“逆向搜索策略”。在解析每一行时，先定位关键字符（如“分”字或冒号），再通过指针移动精准捕捉数值区域，并结合 `atof` 和 `atoi` 进行可靠转换。

2. 关键项目漏录与数组越界
   - 问题描述：系统初期仅支持 6 项体测数据，忽略了“坐位体前屈”项目。增加该项目后，系统频繁出现内存错误。
   - 原因分析：`PROJECT_COUNT` 常量未统一更新，导致 `project_score` 数组越界访问；同时导入模板中增加了列，使得旧的解析逻辑失效。
   - 解决方案：将 `PROJECT_COUNT` 统一宏定义为 7，同步更新 `create_student_node` 中的数组处理逻辑，并重写了 `import_from_custom_txt` 算法以支持不规则格式的兼容处理。

3. 指针传参的作用域问题（空链表插入失败）
   - 问题描述：在编写录入或导入函数时，发现即使函数内部显示“载入成功”，但返回主菜单后链表依然为空。
   - 原因分析：涉及 C 语言的基础概念“值传递”。当时仅传入了一级指针（如 `struct student *head`），函数内部接收的是该指针的一个副本。当原链表为空（`head == NULL`）时，在函数内为该副本分配新节点并赋值，并不会改变调用方（主函数）中真正的头指针地址。
   - 解决方案：将所有涉及链表修改（增、删、改、排）的函数参数全部统一为**二级指针 (struct student **head_ref)**。通过传递头指针的地址，使得函数内部能够直接解引用并修改主函数中的头指针变量，从而确保了空链表状态下的初始化以及后续任何修改都能全局生效。

4. 链表排序时的指针丢失
   - 问题描述：执行排序功能后，链表经常发生断裂，导致后续无法完整遍历，甚至引发程序崩溃。
   - 原因分析：传统的冒泡排序在单链表上仅交换数值效率虽高但不够健壮。在进行“物理节点交换”时，若前序节点的 `next` 指向更新有误，就会导致后续节点“失踪”。
   - 解决方案：引入了**二级指针 (struct student **curr_ptr_ref)** 操作技巧。通过操作指针的地址，统一了头节点和中间节点的交换逻辑，确保了指针重定向的原子性和完整性，实现了稳定的升序/降序排列。

5. 编码兼容性问题（GBK vs UTF-8）
   - 问题描述：在不同编辑器或终端中运行程序时，菜单输出出现乱码，导入带中文的文件时姓名解析错误。
   - 原因分析：源码保存格式（UTF-8）与 Windows 默认 CMD 环境（GBK/CP936）或旧模板文件编码不一致。
   - 解决方案：在开发环境中使用统一的编码声明，并在导入/导出算法中采用缓冲区逐行读取，确保中文字符串（姓名、班级、项目名）在跨平台运行时的稳定性。

6. 动态内存管理
   - 问题描述：程序反复运行录入/导出后，内存占用持续升高。
   - 原因分析：退出系统或刷新数据时，旧的链表节点没有被释放 (free)，造成内存泄漏。
   - 解决方案：实现了 `delete_student_list` 函数，在程序退出或重载数据前，递归/迭代释放所有动态分配的节点，保证系统在长时间运行下的资源利用率。
